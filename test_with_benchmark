#include <gtest/gtest.h>
#include <benchmark/benchmark.h>
#include "Queue.hpp"
#include "array.hpp"
#include "Stack.hpp"
#include "Dlist.hpp"
#include "hash.hpp"
#include "Spisok.hpp" 
#include "tree.hpp"

// Тесты для Queue
TEST(QueueTest, PushAndPop) {
    Queue queue;
    queue.push("first");
    queue.push("second");
    
    EXPECT_EQ(queue.getfront(), "first"); // Проверяем значение перед удалением
    queue.pop(); // Удаляем первый элемент
    EXPECT_EQ(queue.getfront(), "second"); // Проверяем значение после удаления
    queue.pop(); // Удаляем второй элемент
    EXPECT_THROW(queue.getfront(), std::runtime_error); // Проверяем, что очередь пуста
}

// Тесты для класса Array
TEST(ArrayTest, AddEnd) {
    Array array;
    array.addEnd("first");
    array.addEnd("second");
    
    EXPECT_EQ(array.get(0), "first");
    EXPECT_EQ(array.get(1), "second");
}

TEST(ArrayTest, RemoveAtIndex) {
    Array array;
    array.addEnd("first");
    array.addEnd("second");
    array.removeAtIndex(0);
    
    EXPECT_EQ(array.get(0), "second");
}

// Тесты для класса Stack
TEST(StackTest, PushAndPop) {
    Stack stack;
    stack.push("first");
    stack.push("second");
    
    EXPECT_EQ(stack.pop(), "second"); // Проверяем значение, которое удаляем
    EXPECT_EQ(stack.pop(), "first"); // Проверяем значение, которое удаляем
    EXPECT_TRUE(stack.isEmpty()); // Проверяем, что стек пуст
}

TEST(StackTest, IsEmpty) {
    Stack stack;
    EXPECT_TRUE(stack.isEmpty()); // Стек должен быть пустым
    stack.push("element");
    EXPECT_FALSE(stack.isEmpty()); // Стек не должен быть пустым
    stack.pop();
    EXPECT_TRUE(stack.isEmpty()); // Стек должен быть снова пустым
}

// Тесты для DoublyLinkedList
TEST(DoublyLinkedListTest, AddAndDelete) {
    DoublyLinkedList list;
    list.addToHead("first");
    list.addToTail("second");

    EXPECT_EQ(list.getHead()->data, "first"); // Проверяем данные головы
    EXPECT_EQ(list.getTail()->data, "second"); // Проверяем данные хвоста

    list.deleteFromTail(); // Удаляем хвост
    EXPECT_EQ(list.getHead()->data, "first"); // Проверяем данные головы после удаления

    list.deleteFromHead(); // Удаляем голову
    EXPECT_EQ(list.getHead(), nullptr); // Проверяем, что список пуст
}

TEST(DoublyLinkedListTest, LoadAndSave) {
    DoublyLinkedList list;
    list.addToHead("first");
    list.addToTail("second");
    list.saveToFile("test.txt");

    DoublyLinkedList newList;
    newList.loadFromFile("test.txt");

    EXPECT_EQ(newList.getHead()->data, "first"); // Проверяем данные головы после загрузки
    EXPECT_EQ(newList.getTail()->data, "second"); // Проверяем данные хвоста после загрузки
}

// Тесты для Hash
TEST(HashTest, BasicOperations) {
    Hash hashTable;

    // Добавление элементов
    hashTable.hset("key1", "value1");
    hashTable.hset("key2", "value2");
    hashTable.hset("key3", "value3");

    // Проверка получения значений
    EXPECT_EQ(hashTable.hget("key1"), "value1");
    EXPECT_EQ(hashTable.hget("key2"), "value2");
    EXPECT_EQ(hashTable.hget("key3"), "value3");
    EXPECT_EQ(hashTable.hget("key4"), "Ключ не найден"); // Проверка отсутствующего ключа

    // Обновление значения
    hashTable.hset("key1", "newValue1");
    EXPECT_EQ(hashTable.hget("key1"), "newValue1"); // Проверка обновленного значения

    // Удаление элемента
    hashTable.hdel("key2");
    EXPECT_EQ(hashTable.hget("key2"), "Ключ не найден"); // Проверка удаления
    EXPECT_EQ(hashTable.hget("key1"), "newValue1"); // Проверка, что другие элементы не затронуты
    EXPECT_EQ(hashTable.hget("key3"), "value3"); // Проверка, что другие элементы не затронуты

    // Удаление несуществующего ключа
    hashTable.hdel("key4"); // Должно вывести сообщение о том, что ключ не найден
}

TEST(HashTest, CollisionHandling) {
    Hash hashTable;

    // Добавление нескольких элементов с одинаковым хеш-значением
    hashTable.hset("key1", "value1");
    hashTable.hset("key2", "value2"); // Предположим, что эти ключи имеют одинаковый хеш
    hashTable.hset("key3", "value3"); // И этот тоже

    // Проверка получения значений
    EXPECT_EQ(hashTable.hget("key1"), "value1");
    EXPECT_EQ(hashTable.hget("key2"), "value2");
    EXPECT_EQ(hashTable.hget("key3"), "value3");
}

// Тесты для Spisok
TEST(SpisokTest, AddHeadAndTail) {
    Spisok list;
    list.addHead("first");
    list.addTail("second");

    EXPECT_EQ(list.getHead()->value, "first");  // Проверяем значение головы
    EXPECT_EQ(list.getHead()->next->value, "second");  // Проверяем значение второго узла
}

TEST(SpisokTest, RemoveHead) {
    Spisok list;
    list.addHead("first");
    list.addHead("second");
    list.removeHead();

    EXPECT_EQ(list.getHead()->value, "first");  // Проверяем значение головы после удаления
}

TEST(SpisokTest, RemoveTail) {
    Spisok list;
    list.addTail("first");
    list.addTail("second");
    list.removeTail();

    EXPECT_EQ(list.getHead()->value, "first");  // Проверяем значение головы после удаления хвоста
    EXPECT_EQ(list.getHead()->next, nullptr);    // Проверяем, что хвоста больше нет
}

TEST(SpisokTest, RemoveByValue) {
    Spisok list;
    list.addTail("first");
    list.addTail("second");
    list.addTail("third");
    list.removeByValue("second");

    EXPECT_EQ(list.getHead()->next->value, "third");  // Проверяем, что второй элемент удален
}

TEST(SpisokTest, Search) {
    Spisok list;
    list.addTail("first");
    list.addTail("second");

    EXPECT_TRUE(list.search("first"));  // Проверяем, что элемент найден
    EXPECT_FALSE(list.search("third"));  // Проверяем, что несуществующий элемент не найден
}

// Тесты для AVLTree
TEST(AVLTreeTest, InsertTest) {
    AVLTree tree;

    // Вставка элементов, которые не требуют поворотов
    tree.Insert(10);
    tree.Insert(20);
    tree.Insert(5);

    EXPECT_TRUE(tree.Search(10));  
    EXPECT_TRUE(tree.Search(20));  
    EXPECT_TRUE(tree.Search(5));   
    EXPECT_FALSE(tree.Search(15)); 
}

TEST(AVLTreeTest, DeleteTest) {
    AVLTree tree;
    tree.Insert(10);
    tree.Insert(20);
    tree.Insert(5);
    
    tree.Delete(10);
    
    EXPECT_FALSE(tree.Search(10));
    EXPECT_TRUE(tree.Search(20));  
    EXPECT_TRUE(tree.Search(5));  
}

TEST(AVLTreeTest, BalanceTest) {
    AVLTree tree;

    // Вставка элементов, которые требуют поворота
    tree.Insert(30);
    tree.Insert(20);
    tree.Insert(10); // Это вызовет правый поворот

    EXPECT_TRUE(tree.Search(30));
    EXPECT_TRUE(tree.Search(20));
    EXPECT_TRUE(tree.Search(10));

    // Проверка структуры дерева
    tree.PrintTree(); // Для визуальной проверки
}

TEST(AVLTreeTest, MinValueTest) {
    AVLTree tree;
    
    tree.Insert(10);
    tree.Insert(20);
    tree.Insert(5);
    tree.Insert(3);
    tree.Insert(7);
    
    EXPECT_EQ(tree.FindMin(), 3);
}

TEST(AVLTreeTest, HeightTest) {
    AVLTree tree;
    
    tree.Insert(10);
    tree.Insert(20);
    tree.Insert(5);
    tree.Insert(4);
    
    EXPECT_EQ(tree.Height(), 3); 
}

TEST(AVLTreeTest, WriteToFileTest) {
    AVLTree tree;
    tree.Insert(10);
    tree.Insert(20);
    tree.Insert(5);
    
    tree.WriteToFile("tree.txt");

    std::ifstream file("tree.txt");
    EXPECT_TRUE(file.is_open());  
    file.close();
}

TEST(AVLTreeTest, ClearTest) {
    AVLTree tree;
    
    tree.Insert(10);
    tree.Insert(20);
    tree.Insert(5);
    
    tree.Clear();
    
    EXPECT_FALSE(tree.Search(10)); 
    EXPECT_FALSE(tree.Search(20)); 
    EXPECT_FALSE(tree.Search(5));  
}

TEST(AVLTreeTest, DoubleRotationTest) {
    AVLTree tree;

    // Вставка, которая потребует двойного поворота
    tree.Insert(30);
    tree.Insert(10);
    tree.Insert(20); // Это вызовет сначала левый поворот, а затем правый

    EXPECT_TRUE(tree.Search(30));
    EXPECT_TRUE(tree.Search(10));
    EXPECT_TRUE(tree.Search(20));

    // Проверка структуры дерева
    tree.PrintTree(); // Для визуальной проверки
}

// Бенчмарки
static void BenchmarkQueue(benchmark::State& state) {
    Queue queue;
    for (auto _ : state) {
        queue.push("element");
        queue.pop();
    }
}

static void BenchmarkArray(benchmark::State& state) {
    Array array;
    for (auto _ : state) {
        array.addEnd("element");
        array.removeAtIndex(0);
    }
}

static void BenchmarkStack(benchmark::State& state) {
    Stack stack;
    for (auto _ : state) {
        stack.push("element");
        stack.pop();
    }
}

static void BenchmarkDoublyLinkedList(benchmark::State& state) {
    DoublyLinkedList list;
    for (auto _ : state) {
        list.addToTail("element");
        list.deleteFromHead();
    }
}

static void BenchmarkHash(benchmark::State& state) {
    Hash hashTable;
    for (auto _ : state) {
        hashTable.hset("key", "value");
        hashTable.hget("key");
        hashTable.hdel("key");
    }
}

static void BenchmarkSpisok(benchmark::State& state) {
    Spisok list;
    for (auto _ : state) {
        list.addTail("element");
        list.removeHead();
    }
}

static void BenchmarkAVLTree(benchmark::State& state) {
    AVLTree tree;
    for (auto _ : state) {
        tree.Insert(10);
        tree.Delete(10);
    }
}

// Регистрация бенчмарков
BENCHMARK(BenchmarkQueue);
BENCHMARK(BenchmarkArray);
BENCHMARK(BenchmarkStack);
BENCHMARK(BenchmarkDoublyLinkedList);
BENCHMARK(BenchmarkHash);
BENCHMARK(BenchmarkSpisok);
BENCHMARK(BenchmarkAVLTree);

// Запуск всех тестов и бенчмарков
int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    benchmark::Initialize(&argc, argv);
    benchmark::RunSpecifiedBenchmarks();
    return RUN_ALL_TESTS();
}
